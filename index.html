<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Sayƒ± Avcƒ±sƒ± ‚Äì Tek & √áift Ki≈üilik</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background:
        radial-gradient(circle at top, #4f46e5 0, #020617 45%) fixed,
        radial-gradient(circle at bottom, #ec4899 0, #000000 50%) fixed;
      color: #e5e7eb;
    }

    .game-wrapper {
      background: rgba(15, 23, 42, 0.92);
      border-radius: 24px;
      border: 2px solid rgba(129, 140, 248, 0.7);
      box-shadow:
        0 0 25px rgba(129, 140, 248, 0.7),
        0 0 60px rgba(236, 72, 153, 0.4);
      padding: 20px 24px 24px;
      max-width: 600px;
      width: 100%;
    }

    h1 {
      text-align: center;
      font-size: 28px;
      margin-bottom: 4px;
      color: #f97316;
      text-shadow: 0 0 12px rgba(249, 115, 22, 0.9);
      letter-spacing: 1px;
    }

    .subtitle {
      text-align: center;
      font-size: 14px;
      margin-bottom: 14px;
      color: #e5e7eb;
      opacity: 0.85;
    }

    .settings {
      border-radius: 16px;
      padding: 12px 14px;
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 1) 0, rgba(2, 6, 23, 0.9) 55%);
      border: 1px solid rgba(148, 163, 184, 0.7);
      margin-bottom: 12px;
      font-size: 13px;
    }

    .settings-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 8px;
      align-items: center;
    }

    .settings label {
      font-size: 12px;
      opacity: 0.9;
    }

    .settings input[type="text"],
    .settings select {
      background: #020617;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      padding: 4px 10px;
      color: #e5e7eb;
      font-size: 12px;
      outline: none;
    }

    .settings input[type="text"]::placeholder {
      color: #6b7280;
    }

    .mode-options {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .mode-options label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      cursor: pointer;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 13px;
      gap: 8px;
      flex-wrap: wrap;
    }

    .status-pill {
      padding: 4px 10px;
      border-radius: 999px;
      background: radial-gradient(circle at top left, #22c55e 0, #0f172a 40%);
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.6);
      color: #e5e7eb;
      white-space: nowrap;
    }

    .status-pill span {
      font-weight: 600;
      color: #bbf7d0;
    }

    .status-pill.secondary {
      background: radial-gradient(circle at top left, #06b6d4 0, #0f172a 40%);
      box-shadow: 0 0 10px rgba(6, 182, 212, 0.6);
      color: #e0f2fe;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 7px 16px;
      background: linear-gradient(135deg, #22c55e, #a3e635);
      color: #022c22;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, filter 0.15s ease;
      box-shadow: 0 0 14px rgba(74, 222, 128, 0.9);
      text-transform: uppercase;
      letter-spacing: 0.06em;
      font-size: 10px;
      white-space: nowrap;
    }

    .btn:hover {
      filter: brightness(1.1);
    }

    .btn:active {
      transform: translateY(1px) scale(0.97);
      box-shadow: 0 0 8px rgba(74, 222, 128, 0.7);
    }

    .grid-wrapper {
      margin-top: 10px;
      max-height: 460px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(52px, 1fr));
      gap: 8px;
    }

    .cell {
      position: relative;
      width: 100%;
      padding-top: 100%; /* kare */
    }

    .number-btn {
      position: absolute;
      inset: 0;
      border-radius: 16px;
      border: 2px solid rgba(148, 163, 184, 0.8);
      background: radial-gradient(circle at top, #0f172a 0, #020617 55%);
      color: #e5e7eb;
      font-size: 22px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition:
        transform 0.12s ease,
        box-shadow 0.15s ease,
        border-color 0.15s ease,
        background 0.15s ease,
        opacity 0.28s ease;
      box-shadow:
        0 0 8px rgba(148, 163, 184, 0.7),
        inset 0 0 10px rgba(15, 23, 42, 0.9);
      user-select: none;
    }

    .number-btn:active {
      transform: translateY(2px) scale(0.96);
      box-shadow: 0 0 6px rgba(148, 163, 184, 0.7);
    }

    .number-btn.correct {
      animation: popOut 0.35s forwards;
      background: radial-gradient(circle at top, #22c55e 0, #166534 60%);
      border-color: #bbf7d0;
      box-shadow:
        0 0 18px rgba(74, 222, 128, 1),
        0 0 40px rgba(22, 163, 74, 0.9);
      color: #022c22;
    }

    .number-btn.wrong {
      animation: shake 0.25s;
      background: radial-gradient(circle at top, #b91c1c 0, #450a0a 60%);
      border-color: #fecaca;
      box-shadow:
        0 0 18px rgba(248, 113, 113, 1),
        0 0 32px rgba(185, 28, 28, 0.9);
      color: #fee2e2;
    }

    /* SONU√á OVERLAY */
    .finished-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, rgba(15, 23, 42, 0.98) 0, rgba(0, 0, 0, 0.8) 55%);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .finished-card {
      background: rgba(15, 23, 42, 0.95);
      border: 2px solid rgba(250, 204, 21, 0.9);
      border-radius: 24px;
      padding: 20px 24px;
      text-align: center;
      max-width: 360px;
      box-shadow:
        0 0 20px rgba(250, 204, 21, 0.9),
        0 0 40px rgba(234, 179, 8, 0.8);
      animation: popIn 0.4s ease;
      color: #fef9c3;
    }

    .finished-card h2 {
      font-size: 24px;
      margin-bottom: 6px;
      text-shadow: 0 0 12px rgba(250, 250, 150, 1);
    }

    .finished-card p {
      margin-bottom: 8px;
      font-size: 14px;
      white-space: pre-line; /* \n varsa satƒ±r atla */
    }

    .big-emoji {
      font-size: 40px;
      margin-bottom: 8px;
      animation: bounce 1s infinite;
    }

    .mode-text {
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 8px;
    }

    .btn-small {
      font-size: 10px;
      padding: 5px 12px;
    }

    /* KONFETƒ∞ YILDIZLAR */
    .confetti-container {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 2000;
    }

    .confetti-star {
      position: absolute;
      top: -20px;
      font-size: 18px;
      animation: star-fall 2.6s linear forwards;
    }

    @keyframes star-fall {
      0% {
        transform: translateY(-20px) rotate(0deg);
        opacity: 1;
      }
      100% {
        transform: translateY(110vh) rotate(360deg);
        opacity: 0;
      }
    }

    /* Kazanan ismin yanƒ±p s√∂nme efekti */
    @keyframes winner-blink {
      0%, 100% {
        opacity: 1;
        text-shadow:
          0 0 8px rgba(250, 204, 21, 1),
          0 0 16px rgba(234, 179, 8, 0.9);
      }
      50% {
        opacity: 0.2;
        text-shadow:
          0 0 2px rgba(250, 204, 21, 0.6),
          0 0 6px rgba(234, 179, 8, 0.5);
      }
    }

    .winner-name {
      color: #facc15;
      font-weight: 700;
      animation: winner-blink 0.9s infinite;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-4px); }
      40% { transform: translateX(4px); }
      60% { transform: translateX(-3px); }
      80% { transform: translateX(3px); }
    }

    @keyframes popOut {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.12); opacity: 1; }
      100% { transform: scale(0.4); opacity: 0; pointer-events: none; }
    }

    @keyframes popIn {
      0% { transform: scale(0.6); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-7px); }
    }

    @media (max-width: 540px) {
      .game-wrapper {
        padding: 16px 14px 18px;
        margin: 10px;
      }
      h1 {
        font-size: 23px;
      }
      .number-btn {
        font-size: 18px;
      }
    }
  </style>
</head>
<body>

<div class="game-wrapper">
  <h1>Sayƒ±larƒ± Sƒ±rala</h1>
  <p class="subtitle">
    Modu se√ß, ritmik saymayƒ± ayarla, sonra BA≈ûLAT‚Äôa bas ve sayƒ±lara sƒ±rayla dokun.
  </p>

  <!-- Ayarlar -->
  <div class="settings">
    <div class="settings-row">
      <span>Oyun Modu:</span>
      <div class="mode-options">
        <label>
          <input type="radio" name="mode" value="single" checked />
          Tek Ki≈üilik
        </label>
        <label>
          <input type="radio" name="mode" value="two" />
          ƒ∞ki Ki≈üilik
        </label>
      </div>
    </div>

    <div class="settings-row">
      <label for="player1-name">1. Oyuncu:</label>
      <input id="player1-name" type="text" placeholder="√ñrn: Elif" />
      <label for="player2-name">2. Oyuncu:</label>
      <input id="player2-name" type="text" placeholder="ƒ∞ki ki≈üilikte doldurun" />
    </div>

    <div class="settings-row">
      <label for="limit-select">Sayƒ± sƒ±nƒ±rƒ±:</label>
      <select id="limit-select">
        <option value="10">Kolay: 1‚Äì10</option>
        <option value="20" selected>Orta: 1‚Äì20</option>
        <option value="100">Zor / Ritmik: 1‚Äì100</option>
      </select>

      <label for="step-select">Ritmik sayma:</label>
      <select id="step-select">
        <option value="1">1'er (1,2,3,...)</option>
        <option value="2">2'≈üer (2,4,6,...)</option>
        <option value="3">3'er (3,6,9,...)</option>
        <option value="4">4'er</option>
        <option value="5">5'er</option>
        <option value="6">6'≈üar</option>
        <option value="7">7'≈üer</option>
        <option value="8">8'er</option>
        <option value="9">9'ar</option>
        <option value="10">10'ar</option>
      </select>
    </div>
  </div>

  <!-- Durum √áubuklarƒ± + Ba≈ülat -->
  <div class="status-bar">
    <div class="status-pill">
      Sƒ±radaki sayƒ±: <span id="next-number">-</span>
    </div>
    <div class="status-pill secondary">
      Aktif oyuncu: <span id="player-label">Yok</span>
    </div>
    <button id="start-btn" class="btn">BA≈ûLAT</button>
  </div>

  <div class="status-bar">
    <div class="status-pill secondary">
      S√ºre: <span id="time">0.0</span> sn
    </div>
    <div class="status-pill secondary">
      En iyi (tek ki≈üilik): <span id="best-time">-</span>
    </div>
  </div>

  <div class="grid-wrapper">
    <div id="grid" class="grid"></div>
  </div>
</div>

<!-- Sonu√ß Penceresi -->
<div id="finished-overlay" class="finished-overlay">
  <div class="finished-card">
    <div class="big-emoji">üéâ</div>
    <h2>Oyun Bitti!</h2>
    <p id="finish-text">Sayƒ±larƒ± sƒ±rayla buldun!</p>
    <p class="mode-text" id="finish-mode-text"></p>
    <button id="play-again-btn" class="btn btn-small">Tekrar Oyna</button>
  </div>
</div>

<script>
  const gridEl = document.getElementById("grid");
  const nextNumberEl = document.getElementById("next-number");
  const timeEl = document.getElementById("time");
  const bestTimeEl = document.getElementById("best-time");
  const playerLabelEl = document.getElementById("player-label");
  const startBtn = document.getElementById("start-btn");

  const player1Input = document.getElementById("player1-name");
  const player2Input = document.getElementById("player2-name");
  const limitSelect = document.getElementById("limit-select");
  const stepSelect = document.getElementById("step-select");

  const finishedOverlay = document.getElementById("finished-overlay");
  const finishTextEl = document.getElementById("finish-text");
  const finishModeTextEl = document.getElementById("finish-mode-text");
  const playAgainBtn = document.getElementById("play-again-btn");

  // Durum deƒüi≈ükenleri
  let mode = "single"; // "single" | "two"
  let currentLimit = parseInt(limitSelect.value, 10);
  let currentStep = parseInt(stepSelect.value, 10);
  let currentSequence = [];
  let currentNumber = null;
  let gameStarted = false;

  let timerInterval = null;
  let startTime = null;

  // Tek ki≈üilik rekorlar (limit+step'e g√∂re)
  const BEST_KEY = "sayiArcadeBestTimes_v2";
  let bestTimes = {};

  // √áift ki≈üilik i√ßin oyuncular
  let players = [
    { name: "Oyuncu 1", time: null },
    { name: "Oyuncu 2", time: null }
  ];
  let currentPlayerIndex = 0; // 0 veya 1

  // Ses sistemi
  let audioCtx = null;
  function getAudioContext() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioCtx;
  }

  function playBeep(freq, duration, type = "square", volume = 0.2) {
    try {
      const ctx = getAudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, ctx.currentTime);
      gain.gain.setValueAtTime(volume, ctx.currentTime);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration / 1000);
      osc.stop(ctx.currentTime + duration / 1000);
    } catch (e) {}
  }

  function playCorrectSound() {
    playBeep(800, 90, "square", 0.28);
    setTimeout(() => playBeep(1100, 90, "square", 0.24), 90);
  }

  function playWrongSound() {
    playBeep(220, 200, "sawtooth", 0.22);
  }

  function playApplause() {
    // Hƒ±zlƒ± k√º√ß√ºk biplerle "alkƒ±≈ü benzeri" bir efekt
    for (let i = 0; i < 25; i++) {
      const delay = i * 50;
      setTimeout(() => {
        const f = 300 + Math.random() * 400;
        playBeep(f, 70, "square", 0.18);
      }, delay);
    }
  }

  // Konfeti yƒ±ldƒ±zlar
  function triggerConfetti() {
    const container = document.createElement("div");
    container.className = "confetti-container";

    const colors = ["#facc15", "#f97316", "#22c55e", "#38bdf8", "#e879f9", "#f9a8d4"];

    for (let i = 0; i < 40; i++) {
      const star = document.createElement("div");
      star.className = "confetti-star";
      star.textContent = "‚òÖ";
      const left = Math.random() * 100;
      const delay = Math.random() * 0.8;
      const color = colors[Math.floor(Math.random() * colors.length)];
      star.style.left = left + "vw";
      star.style.animationDelay = delay + "s";
      star.style.color = color;
      container.appendChild(star);
    }

    document.body.appendChild(container);
    setTimeout(() => {
      container.remove();
    }, 2800);
  }

  // Zamanlayƒ±cƒ±
  function startTimer() {
    startTime = performance.now();
    timerInterval = setInterval(() => {
      const now = performance.now();
      const seconds = (now - startTime) / 1000;
      timeEl.textContent = seconds.toFixed(1);
    }, 100);
  }

  function stopTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  }

  // Rekorlar
  function loadBestTimes() {
    try {
      const raw = localStorage.getItem(BEST_KEY);
      bestTimes = raw ? JSON.parse(raw) : {};
      if (typeof bestTimes !== "object" || bestTimes === null) bestTimes = {};
    } catch (e) {
      bestTimes = {};
    }
  }

  function saveBestTimes() {
    try {
      localStorage.setItem(BEST_KEY, JSON.stringify(bestTimes));
    } catch (e) {}
  }

  function getModeKey(limit, step) {
    return limit + "-" + step;
  }

  // Sƒ±ra √ºretme (ritmik sayma listesi)
  function createSequence(limit, step) {
    const result = [];
    for (let n = step; n <= limit; n += step) {
      result.push(n);
    }
    return result;
  }

  // Grid kur
  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  function createGrid() {
    gridEl.innerHTML = "";
    if (!currentSequence.length) {
      const msg = document.createElement("div");
      msg.style.padding = "12px";
      msg.textContent = "Bu ayarlarda sayƒ± yok. L√ºtfen ritim/sƒ±nƒ±rƒ± deƒüi≈ütirin.";
      gridEl.appendChild(msg);
      return;
    }

    let numbers = shuffle([...currentSequence]);
    numbers.forEach(num => {
      const cell = document.createElement("div");
      cell.className = "cell";
      const btn = document.createElement("button");
      btn.className = "number-btn";
      btn.textContent = num;
      btn.dataset.number = num;
      btn.addEventListener("click", () => handleNumberClick(btn));
      cell.appendChild(btn);
      gridEl.appendChild(cell);
    });
  }

  function handleNumberClick(btn) {
    if (!gameStarted) return;

    getAudioContext(); // ses i√ßin ilk etkile≈üim

    const num = parseInt(btn.dataset.number, 10);

    if (num === currentNumber) {
      // DOƒûRU
      btn.classList.remove("wrong");
      btn.classList.add("correct");
      btn.style.pointerEvents = "none";
      playCorrectSound();

      // ƒ∞lk doƒüru ise s√ºreyi ba≈ülat
      if (currentNumber === currentSequence[0] && !timerInterval) {
        startTimer();
      }

      // Sƒ±radaki sayƒ±ya ge√ß
      const idx = currentSequence.indexOf(currentNumber);
      const nextIdx = idx + 1;
      currentNumber = currentSequence[nextIdx] ?? null;
      nextNumberEl.textContent = currentNumber ? currentNumber : "-";

      // Bitti mi?
      if (!currentNumber) {
        gameStarted = false;
        stopTimer();
        const totalSeconds = parseFloat(timeEl.textContent);
        if (mode === "single") {
          handleSingleFinish(totalSeconds);
        } else {
          handleTwoFinish(totalSeconds);
        }
      }
    } else {
      // YANLI≈û
      btn.classList.remove("correct");
      btn.classList.add("wrong");
      playWrongSound();
      setTimeout(() => {
        btn.classList.remove("wrong");
      }, 260);
    }
  }

  // Tek ki≈üilik biti≈ü
  function handleSingleFinish(totalSeconds) {
    if (isNaN(totalSeconds)) return;

    const limit = currentLimit;
    const step = currentStep;
    const key = getModeKey(limit, step);
    const name = (player1Input.value || "Oyuncu").trim() || "Oyuncu";

    let oldBest = bestTimes[key] ?? null;
    let isNewBest = false;

    if (oldBest === null || totalSeconds < oldBest) {
      bestTimes[key] = totalSeconds;
      saveBestTimes();
      oldBest = totalSeconds;
      isNewBest = true;
    }

    bestTimeEl.textContent = oldBest ? oldBest.toFixed(1) + " sn" : "-";

    finishTextEl.textContent = `S√ºre: ${totalSeconds.toFixed(1)} saniye`;
    if (isNewBest) {
      finishModeTextEl.innerHTML = `Tebrikler <span class="winner-name">${name}</span>! Yeni rekor kƒ±rdƒ±n! üéâ`;
      triggerConfetti();
      playApplause();
    } else {
      finishModeTextEl.textContent = `Mevcut rekor: ${oldBest.toFixed(1)} sn. Tekrar dene, kƒ±rmaya √ßalƒ±≈ü!`;
    }

    finishedOverlay.style.display = "flex";
  }

  // √áift ki≈üilik biti≈ü
  function handleTwoFinish(totalSeconds) {
    if (isNaN(totalSeconds)) return;

    const idx = currentPlayerIndex;
    players[idx].time = totalSeconds;

    if (idx === 0) {
      // 1. oyuncu bitti, ≈üimdi 2. oyuna ge√ß
      currentPlayerIndex = 1;
      playerLabelEl.textContent = players[1].name + " (2. Oyuncu)";
      // ƒ∞kinci oyuncu i√ßin sƒ±fƒ±rla ve hemen yeni grid ba≈ülat
      prepareRunForCurrentPlayer();
    } else {
      // 2. oyuncu da bitti, kazananƒ± bul
      const t1 = players[0].time;
      const t2 = players[1].time;

      let winnerHTML = "";
      if (t1 < t2) {
        winnerHTML = `Kazanan: <span class="winner-name">${players[0].name}</span> üèÜ`;
      } else if (t2 < t1) {
        winnerHTML = `Kazanan: <span class="winner-name">${players[1].name}</span> üèÜ`;
      } else {
        winnerHTML = "Berabere! üëè";
      }

      // Her iki oyuncunun adƒ± ve s√ºresi satƒ±r satƒ±r g√∂r√ºns√ºn
      finishTextEl.innerHTML =
        `1. Oyuncu: <strong>${players[0].name}</strong> ‚Äì ${t1.toFixed(1)} sn<br>` +
        `2. Oyuncu: <strong>${players[1].name}</strong> ‚Äì ${t2.toFixed(1)} sn`;

      finishModeTextEl.innerHTML = winnerHTML;

      triggerConfetti();
      playApplause();

      finishedOverlay.style.display = "flex";
    }
  }

  // Se√ßili oyuncu i√ßin yeni turu hazƒ±rla
  function prepareRunForCurrentPlayer() {
    stopTimer();
    timeEl.textContent = "0.0";
    currentSequence = createSequence(currentLimit, currentStep);
    if (!currentSequence.length) {
      gridEl.innerHTML = "<div style='padding:12px'>Bu ayarlarda sayƒ± yok. L√ºtfen ritim/sƒ±nƒ±r deƒüi≈ütirin.</div>";
      nextNumberEl.textContent = "-";
      gameStarted = false;
      return;
    }
    currentNumber = currentSequence[0];
    nextNumberEl.textContent = currentNumber;
    createGrid();
    gameStarted = true;
  }

  // Yeni oyun / ba≈ülat
  function startNewMatch() {
    // Modu oku
    const modeInput = document.querySelector('input[name="mode"]:checked');
    mode = modeInput ? modeInput.value : "single";

    currentLimit = parseInt(limitSelect.value, 10);
    currentStep = parseInt(stepSelect.value, 10);

    if (mode === "single") {
      currentPlayerIndex = 0;
      const name = (player1Input.value || "Oyuncu").trim() || "Oyuncu";
      playerLabelEl.textContent = `${name} (Tek)`;

      // Rekor g√∂ster
      const key = getModeKey(currentLimit, currentStep);
      const best = bestTimes[key] ?? null;
      bestTimeEl.textContent = best ? best.toFixed(1) + " sn" : "-";

      prepareRunForCurrentPlayer();
    } else {
      // ƒ∞ki ki≈üilik
      players[0].name = (player1Input.value || "Oyuncu 1").trim() || "Oyuncu 1";
      players[1].name = (player2Input.value || "Oyuncu 2").trim() || "Oyuncu 2";
      players[0].time = null;
      players[1].time = null;

      currentPlayerIndex = 0;
      playerLabelEl.textContent = `${players[0].name} (1. Oyuncu)`;
      bestTimeEl.textContent = "-"; // √áift modda rekor yok, sadece yarƒ±≈ü

      prepareRunForCurrentPlayer();
    }
  }

  // Eventler
  startBtn.addEventListener("click", () => {
    finishedOverlay.style.display = "none";
    startNewMatch();
  });

  playAgainBtn.addEventListener("click", () => {
    finishedOverlay.style.display = "none";
    startNewMatch();
  });

  // Ba≈ülangƒ±√ß
  loadBestTimes();
  gridEl.innerHTML = "<div style='padding:12px'>Oyuna ba≈ülamak i√ßin BA≈ûLAT'a basƒ±n.</div>";
</script>

</body>
</html>
